### Задание на лабораторную работу по РЕДОС
1. Создайте свой каталог в директории /home/user/ Все скрипты создавайте внутри этого каталога или его подкаталогов. (mkdir lab1)
2. Напишите скрипты, решающие следующие задачи:
i) В параметрах при запуске скрипта передаются три целых числа. Вывести максимальное из них.
ii) Считывать строки с клавиатуры, пока не будет введена строка "q". После этого вывести последовательность считанных строк в виде одной строки.
iii) Создать текстовое меню с четырьмя пунктами. При вводе пользователем номера пункта меню происходит запуск редактора nano, редактора vi, браузера links или выход из меню.
iv) Если скрипт запущен из домашнего директория, вывести на экран путь к домашнему директорию и выйти с кодом 0. В противном случае вывести сообщение об ошибке и выйти с кодом 1.
v) Создать файл info.log, в который поместить все строки из файла /var/log/anaconda/syslog, второе поле в которых равно INFO.
vi) Создать full.log, в который вывести строки файла /var/log/anaconda/X.log, содержащие предупреждения и информационные сообщения, заменив маркеры предупреждений и информационных сообщений на слова Warning: и Information:, чтобы в получившемся файле сначала шли все предупреждения, а потом все информационные сообщения. Вывести этот файл на экран.
vii) Создать файл emails.lst, в который вывести через запятую все адреса электронной почты, встречающиеся во всех файлах директории /etc.
viii) Вывести список пользователей системы с указанием их UID, отсортировав по UID. Сведения о пользователей хранятся в файле /etc/passwd. В каждой строке этого файла первое поле – имя пользователя, третье поле – UID. Разделитель – двоеточие.
ix) Подсчитать общее количество строк в файлах, находящихся в директории /var/log/ и имеющих расширение log.
x) Вывести три наиболее часто встречающихся слова из man по команде bash длиной не менее четырех символов.
3. Предъявите скрипты преподавателю и получите вопрос или задание для защиты лабораторной работы.
4. После защиты лабораторной работы удалите созданный директорий со всем его содержимым
(rm –R lab1)


Задание на лабораторную работу
1. Создайте свой каталог в директории /home/user/ Все скрипты и файлы для вывода результатов создавайте внутри этого каталога или его подкаталогов. (mkdir lab2)
2. Напишите скрипты, решающие следующие задачи:
i) Посчитать количество процессов, запущенных пользователем user, и вывести в файл получившееся число, а затем пары PID:команда для таких процессов.
ii) Вывести в файл список PID всех процессов, которые были запущены командами, расположенными в /sbin/
iii) Вывести на экран PID процесса, запущенного последним (с последним временем запуска).
iv) Для всех зарегистрированных в данный момент в системе процессов определить среднее время непрерывного использования процессора (CPU_burst) и вывести в один файл строки ProcessID=PID : Parent_ProcessID=PPID : Average_Running_Time=ART. Значения PPid взять из файлов status, которые находятся в директориях с названиями, соответствующими PID процессов в /proc. Значения ART получить, разделив значение sum_exec_runtime на nr_switches, взятые из файлов sched в этих же директориях. Отсортировать эти строки по идентификаторам родительских процессов.
v) В полученном на предыдущем шаге файле после каждой группы записей с одинаковым идентификатором родительского процесса вставить строку вида Average_Sleeping_Children_of_ParentID=N is M, где N = PPID, а M – среднее, посчитанное из ART для всех процессов этого родителя.
vi) Используя псевдофайловую систему /proc найти процесс, которому выделено больше всего оперативной памяти. Сравнить результат с выводом команды top.
vii) Написать скрипт, определяющий три процесса, которые за 1 минуту, прошедшую с момента запуска скрипта, считали максимальное количество байт из устройства хранения данных. Скрипт должен выводить PID, строки запуска и объем считанных данных, разделенные двоеточием.
3. Предъявите скрипты преподавателю и получите вопрос или задание для защиты лабораторной работы.
Задание на лабораторную работу
Создайте скрипты или запишите последовательности выполнения команд для перечисленных заданий и предъявите их преподавателю.
1. Создайте и однократно выполните скрипт (в этом скрипте нельзя использовать условный оператор и операторы проверки свойств и значений), который будет пытаться создать директорию test в домашней директории. Если создание директории пройдет успешно, скрипт выведет в файл ~/report сообщение вида "catalog test was created successfully" и создаст в директории test файл с именем Дата_Время_Запуска_Скрипта. Затем независимо от результатов предыдущего шага скрипт должен опросить с помощью команды ping хост www.net_nikogo.ru и, если этот хост недоступен, дописать сообщение об ошибке в файл ~/report. Сообщение об ошибке должно начинаться с текущей Дата_Время, а затем содержать через пробел произвольный текст сообщения об ошибке.
2. Задайте еще один однократный запуск скрипта из пункта 1 через 2 минуты. Консоль после этого должна оставаться свободной. Выполнив отдельную команду организуйте слежение за файлом ~/report и выведите на консоль новые строки из этого файла, как только они появятся.
3. Задайте запуск скрипта из пункта 1 в каждую пятую минут каждого часа в день недели, в который вы будете выполнять работу.
4. Создайте три фоновых процесса, выполняющих одинаковый бесконечный цикл вычисления (например, перемножение двух чисел). После запуска процессов должна сохраниться возможность использовать виртуальную консоль, с которой их запустили. Используя команду top, проанализируйте процент использования ресурсов процессора этими процессами. Создайте скрипт, который будет в автоматическом режиме обеспечивать, чтобы тот процесс, который был запущен первым, использовал ресурс процессора не более чем на 10%. Послав сигнал, завершите работу процесса, запущенного третьим. Проверьте, что созданный скрипт по-прежнему удерживает потребление ресурсов процессора первым процессом в заданном диапазоне.
5. Создайте пару скриптов: генератор и обработчик. Процесс «Генератор» передает информацию процессу «Обработчик» с помощью именованного канала. Процесс «Обработчик» должен осуществлять следующую обработку переданных строк: если строка содержит единственный символ «+», то процесс обработчик переключает режим на «сложение» и ждет ввода численных данных. Если строка содержит единственный символ «*», то обработчик переключает режим на «умножение» и ждет ввода численных данных. Если строка содержит целое число, то обработчик осуществляет текущую активную операцию (выбранный режим) над текущим значением вычисляемой переменной и считанным значением (например, складывает или перемножает результат предыдущего вычисления со считанным числом). При запуске скрипта режим устанавливается в «сложение», а вычисляемая переменная приравнивается к 1. В случае получения строки QUIT скрипт «Обработчик» выдает сообщение о плановой остановке и оба скрипта завершают работу. В случае получения любых других значений строки оба скрипта завершают работу с сообщением об ошибке входных данных.
6. Создайте пару скриптов: генератор и обработчик. Процесс «Генератор» считывает с консоли строки в бесконечном цикле. Если считанная строка содержит единственный символ «+», он посылает процессу «Обработчик» сигнал USR1. Если строка содержит единственный символ «*», генератор посылает обработчику сигнал USR2. Если строка содержит слово TERM, генератор посылает обработчику сигнал SIGTERM и завершает свою работу. Другие значения входных строк игнорируются. Обработчик добавляет 2 или умножает на 2 текущее значение обрабатываемого числа (начальное значение принять на единицу) в зависимости от полученного пользовательского сигнала и выводит результат на экран. Вычисление и вывод производятся один раз в секунду. Получив сигнал SIGTERM, «Обработчик» завершает свою работу, выведя сообщения о завершении работы по сигналу от другого процесса.

Задание на лабораторную работу
Создайте скрипты для перечисленных заданий и предъявите их преподавателю.
ВНИМАНИЕ! Все скрипты должны обрабатывать любые сценарии, соответствующие заданию, в том числе некорректный ввод параметров пользователем, использование имен файлов, содержащих необычные, но не запрещенные для использования в именах файлов символы, различные последовательности запусков разработанных скриптов и других действий пользователя в файловой системе. Все возникающие ошибки при выполнении скриптов, в том числе возникающие при выполнении отдельных утилит операционной системы, должны обрабатываться, и содержательные сообщения о них должны выводиться пользователю командами разрабатываемого скрипта.
1. Скрипт rmtrash
a. Скрипту передается один параметр – имя файла в текущем каталоге вызова скрипта.
b. Скрипт проверяет, создан ли скрытый каталог trash в домашнем каталоге пользователя. Если он не создан – создает его.
c. После этого скрипт создает в этом каталоге жесткую ссылку на переданный файл с уникальным именем (например, присваивает каждой новой ссылке имя, соответствующее следующему натуральному числу) и удаляет файл в текущем каталоге.
d. Затем в скрытый файл trash.log в домашнем каталоге пользователя помещается запись, содержащая полный исходный путь к удаленному файлу и имя созданной жесткой ссылки.
2. Скрипт untrash
a. Скрипту передается один параметр – имя файла, который нужно восстановить (без полного пути – только имя).
b. Скрипт по файлу trash.log должен найти все записи, содержащие в качестве имени файла переданный параметр, и выводить по одному на экран полные имена таких файлов с запросом подтверждения.
c. Если пользователь отвечает на подтверждение положительно, то предпринимается попытка восстановить файл по указанному полному пути (создать в соответствующем каталоге жесткую ссылку на файл из trash и удалить соответствующий файл из trash). Если каталога, указанного в полном пути к файлу, уже не существует, то файл восстанавливается в домашний каталог пользователя с выводом соответствующего сообщения. При невозможности создать жесткую ссылку, например, из-за конфликта имен, пользователю предлагается изменить имя восстанавливаемого файла.
3. Скрипт backup
a. Скрипт создаст в /home/user/ каталог с именем Backup-YYYY-MM-DD, где YYYY-MM-DD – дата запуска скрипта, если в /home/user/ нет каталога с именем, соответствующим дате, отстоящей от текущей менее чем на 7 дней. Если в /home/user/ уже есть «действующий» каталог резервного копирования (созданный не ранее 7 дней от даты запуска скрипта), то новый каталог не создается. Для определения текущей даты можно воспользоваться командой date.
b. Если новый каталог был создан, то скрипт скопирует в этот каталог все файлы из каталога /home/user/source/ (для тестирования скрипта создайте такую директорию и набор файлов в ней). После этого скрипт выведет в режиме дополнения в файл /home/user/backup-report следующую информацию: строка со сведениями о создании нового каталога с резервными копиями с указанием его имени и даты создания; список файлов из /home/user/source/, которые были скопированы в этот каталог.
c. Если каталог не был создан (есть «действующий» каталог резервного копирования), то скрипт должен скопировать в него все файлы из /home/user/source/ по следующим правилам: если файла с таким именем в каталоге резервного копирования нет, то он копируется из /home/user/source. Если файл с таким именем есть, то его размер сравнивается с размером одноименного файла в действующем каталоге резервного копирования. Если размеры совпадают, файл не копируется. Если размеры отличаются, то файл копируется c автоматическим созданием версионной копии, таким образом, в действующем каталоге резервного копирования появляются обе версии файла (уже имеющийся файл переименовывается путем добавления дополнительного расширения «.YYYY-MM-DD» (дата запуска скрипта), а скопированный сохраняет имя). После окончания копирования в файл /home/user/backup-report выводится строка о внесении изменений в действующий каталог резервного копирования с указанием его имени и даты внесения изменений, затем строки, содержащие имена добавленных файлов с новыми именами, а затем строки с именами добавленных файлов с существовавшими в действующем каталоге резервного копирования именами с указанием через пробел нового имени, присвоенного предыдущей версии этого файла.
4. Скрипт upback
a. Скрипт должен скопировать в каталог /home/user/restore/ все файлы из актуального на данный момент каталога резервного копирования (имеющего в имени наиболее свежую дату), за исключением файлов с предыдущими версиями.



Эксперимент №1
Подготовительный этап:
Создайте скрипт mem.bash, реализующий следующий сценарий. Скрипт выполняет бесконечный цикл. Перед началом выполнения цикла создается пустой массив и счетчик шагов, инициализированный нулем. На каждом шаге цикла в конец массива добавляется последовательность из 10 элементов, например, (1 2 3 4 5 6 7 8 9 10). Каждый 100000-ый шаг в файл report.log добавляется строка с текущим значением размера массива (перед запуском скрипта, файл обнуляется).
Первый этап:
Задача – оценить изменения параметров, выводимых утилитой top в процессе работы созданного скрипта.
Ход эксперимента:
Запустите созданный скрипт mem.bash. Дождитесь аварийной остановки процесса и вывода в консоль последних сообщений системного журнала. Зафиксируйте в отчете последнюю запись журнала - значения параметров, с которыми произошла аварийная остановка процесса. Также зафиксируйте значение в последней строке файла report.log.
Подготовьте две консоли. В первой запустите утилиту top. Во второй запустите скрипт и переключитесь на первую консоль. Убедитесь, что в top появился запущенный скрипт. Наблюдайте за следующими значениями (и фиксируйте их изменения во времени в отчете):
 значения параметров памяти системы (верхние две строки над основной таблицей);
 значения параметров в строке таблицы, соответствующей работающему скрипту;
 изменения в верхних пяти процессах (как меняется состав и позиции этих процессов).
Проводите наблюдения и фиксируйте их в отчете до аварийной остановки процесса скрипта и его исчезновения из перечня процессов в top.
Посмотрите с помощью команды dmesg | grep "mem.bash" последние две записи о скрипте в системном журнале и зафиксируйте их в отчете. Также зафиксируйте значение в последней строке файла report.log.
Второй этап:
Задача – оценить изменения параметров, выводимых утилитой top в процессе работы нескольких экземпляров созданного скрипта.
Ход эксперимента:
Создайте копию скрипта, созданного на предыдущем этапе, в файл mem2.bash. Настройте её на запись в файл report2.log. Создайте скрипт, который запустит немедленно друг за другом оба скрипта в фоновом режиме.
Подготовьте две консоли. В первой запустите утилиту top. Во второй запустите созданный перед этим скрипт и переключитесь на первую консоль. Убедитесь, что в top появились mem.bash и mem2.bash. Наблюдайте за следующими значениями (и фиксируйте их изменения во времени в отчете):
 значения параметров памяти системы (верхние две строки над основной таблицей);
 значения параметров в строке таблицы, соответствующей работающему скрипту;
 изменения в верхних пяти процессах (как меняется состав и позиции этих процессов).
Проводите наблюдения и фиксируйте их в отчете до аварийной остановки последнего из двух скриптов и их исчезновения из перечня процессов в top.
Посмотрите с помощью команды dmesg | grep "mem[2]*.bash" последние записи о скриптах в системном журнале и зафиксируйте их в отчете. Также зафиксируйте значения в последних строках файлов report.log и report2.log.
Обработка результатов:
Постройте графики изменения каждой из величин, за которыми производилось наблюдение на каждом из этапов. Объясните динамику изменения этих величин исходя из теоретических основ управления памятью в рамках страничной организации памяти с разделом подкачки. Объясните значения пороговых величин: размер массива, при котором произошла аварийная остановка процесса, параметры, зафиксированные в момент аварийной остановки системным журналом. Сформулируйте письменные выводы.
Эксперимент №2
Подготовительный этап:
Создайте копию скрипта mem.bash в файл newmem.bash. Измените копию таким образом, чтобы она завершала работу, как только размер создаваемого массива превысит значение N, передаваемое в качестве параметра скрипту. Уберите запись данных в файл.
Основной этап:
Задача – определить граничные значения потребления памяти, обеспечивающие безаварийную работу для регулярных процессов, запускающихся с заданной интенсивностью.
Ход эксперимента:
Создайте скрипт, который будет запускать newmem.bash каждую секунду, используя один и тот же параметр N так, что всего будет осуществлено K запусков.
Возьмите в качестве значения N, величину, в 10 раз меньшую, чем размер массива, при котором происходила аварийная остановка процесса в первом этапе предыдущего эксперимента. Возьмите в качестве K значение 10. Убедитесь, что все K запусков успешно завершились, и в системном журнале нет записей об аварийной остановке newmem.bash.
Измените значение K на 30 и снова запустите скрипт. Объясните, почему ряд процессов завершился аварийно. Подберите такое максимальное значение N, чтобы при K=30 не происходило аварийных завершений процессов.
Укажите в отчете сформулированные выводы по этому эксперименту и найденное значение N.

Задание на лабораторную работу
1. Работа с файлами и директориями
1. Создать каталог на диске С:\ с именем LAB6. В нем создать файлы с информацией о версии операционной системы, свободной и занятой памяти, жестких дисках, подключенных в системе. Имена файлов должны соответствовать применяемым для получения данных командам.
2. Создать подкаталог TEST, в него скопировать содержимое каталога LAB6. Сделать этот каталог текущим.
3. Создать одной командой файл с содержимым всех файлов каталога TEST.
4. Удалить все файлы в текущем каталоге, кроме созданного последним.
5. Создать текстовый файл со списком использованных команд и параметрами, использованными для выполнения п.п. 1.1–1.4.
2. Запуск и удаление процессов
1. Узнать имя компьютера (хоста). Создать сетевой ресурс \\имя_хостового_компьютера\temp
2. Создать исполняемый файл, производящий копирование любого файла из дериктории C:\Windows объемом более 2 Мбайт на ресурс \\имя_хостового_компьютера\temp с поддержкой продолжения копирования при обрыве.
3. Настроить запуск исполняемого файла из предыдущего пункта по расписанию через 1 минуту.
4. Проверить запуск копирования; если процесс появился, принудительно завершить его до его штатного завершения.
5. Сравнить исходный и конечный файл. Проверить их целостность.
6. Продолжить копирование с места разрыва.
7. Создать текстовый файл со списком использованных команд с параметрами, использованными для выполнения п.п. 2.1–2.6.
3. Работа со службами
1. Получить файл, содержащий список служб, запущенных в системе.
2. Создать командный файл обеспечивающий:
1. остановку служб DNS-client;
2. с временной задержкой, создание файла, содержащего обновленный список служб, запущенных в системе;
3. запуск другого командного файла, сравнивающего файлы, полученные в пп. 3.1 и 3.2, и создающего разностный файл;
4. восстановление работы служб.
3. Создать текстовый файл со списком использованных команд и параметрами, использованными для выполнения пп. 3.1–3.2.
4. Поиск и сортировка информации в файлах
1. Поместить список всех имен драйверов, загруженных в системе, в файл DRIVERS, в табличной форме.
2. Отсортировать полученные в п.п. 4.1 данные в обратном порядке по алфавиту.
3. Создать текстовый файл со списком использованных команд и параметрами, использованными для выполнения п.п. 4.1–4.2
